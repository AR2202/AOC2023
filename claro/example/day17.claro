
alias Coordinate: tuple<int,int>
alias Heatloss: int
alias HeatLossMap: {Coordinate:Heatloss}

function heatloss(coord: Coordinate, newCoord: Coordinate, hmap: HeatLossMap) -> Heatloss {
    var hloss: int = 0;
    var x = coord[0];
    var y = coord[1];
    var xn = newCoord[0];
    var yn = newCoord[1];
    if (x == xn){
        var newY = y + 1;
        while (newY <= yn){
            hloss = hloss + hmap[(xn,newY)];
            newY ++;
        }
        newY = y - 1;
        while (newY >= yn){
            hloss = hloss + hmap[(xn,newY)];
            newY --;
        }
    }
    else{
        var newX = x + 1;
        while (newX <= xn){
            hloss = hloss + hmap[(newX,yn)];
            newX ++;
        }
        newX = x - 1;
        while (newX >= xn){
            hloss = hloss + hmap[(newX,yn)];
            newX --;
        }
    }
    return hloss;
    

}
function reachable(current: struct {coord: Coordinate, from: Coordinate}, hmap: HeatLossMap) -> [tuple<Coordinate,Heatloss>]{
    var x = current.coord[0];
    
    var y = current.coord[1];

    var xPrev = current.from[0];

    if (x==xPrev){

        return [((xnew, y),heatloss((x,y), (xnew,y), hmap)) | xnew in [x-1, x-2, x-3,x+1, x+2, x+3] where (xnew,y) in hmap];
    }
    else {

        return [((x, ynew),heatloss((x,y), (x,ynew), hmap)) | ynew in [y-1, y-2, y-3,y+1, y+2, y+3] where (x, ynew) in hmap];
    }
    
}

# function findShortestPath(startcoord: tuple<int,int>) -> int{
#     var minCostMap: mut {tuple<int, int>: int} = mut {};

# }
var exmap = {(0,0):2,
         (1,0):4,
         (2,0):1,
         (3,0):3,
         (4,0):4,
         (5,0):3,
         (6,0):2,
         (7,0):3};
var exstruct : struct {coord: Coordinate, from: Coordinate} = {coord = (3,0), from = (3,3)};
print(reachable(exstruct,exmap));